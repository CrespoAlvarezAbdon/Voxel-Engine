<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Deep dive open engine: code/utilities.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Deep dive open engine<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">3D graphical voxel engine with AI games API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">utilities.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains the declaration of some general utility code that is not directly related to the engine and could potentially be used in other projects easily.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;concepts&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;ios&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &quot;<a class="el" href="definitions_8h_source.html">definitions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="logger_8h_source.html">logger.h</a>&quot;</code><br />
<code>#include &lt;glm.hpp&gt;</code><br />
</div>
<p><a href="utilities_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a167e92f056637e9db216e99d66f3274e"><td class="memItemLeft" align="right" valign="top"><a id="a167e92f056637e9db216e99d66f3274e" name="a167e92f056637e9db216e99d66f3274e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::floorMod</b> (int a, int b)</td></tr>
<tr class="memdesc:a167e92f056637e9db216e99d66f3274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a % b using floor modulo operations. The equation computed is r = a - b * q where q = (int)((double)a / b) <br /></td></tr>
<tr class="separator:a167e92f056637e9db216e99d66f3274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6599f42c10c6d8607954d98660946d"><td class="memItemLeft" align="right" valign="top"><a id="a2a6599f42c10c6d8607954d98660946d" name="a2a6599f42c10c6d8607954d98660946d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::sign</b> (float real)</td></tr>
<tr class="memdesc:a2a6599f42c10c6d8607954d98660946d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns +1 if 'real' &gt;= 0 and -1 otherwise. <br /></td></tr>
<tr class="separator:a2a6599f42c10c6d8607954d98660946d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe416129c1ccf1dba5268a792d95c2d8"><td class="memItemLeft" align="right" valign="top"><a id="afe416129c1ccf1dba5268a792d95c2d8" name="afe416129c1ccf1dba5268a792d95c2d8"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::indMaxVec</b> (const vec3 &amp;vector)</td></tr>
<tr class="memdesc:afe416129c1ccf1dba5268a792d95c2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first maximum value in 'vector'. For example, if vector = 1.0f, 1.0f, 1.0f, indexMax(vector) will return 0, but if vector = 0.0f, 1.0f, 1.0f, it will return 1. <br /></td></tr>
<tr class="separator:afe416129c1ccf1dba5268a792d95c2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f0d98fcf9602c4bc70126c92f22fe"><td class="memItemLeft" align="right" valign="top"><a id="a348f0d98fcf9602c4bc70126c92f22fe" name="a348f0d98fcf9602c4bc70126c92f22fe"></a>
vec3&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::uDirectionToVec3</b> (blockViewDir direction)</td></tr>
<tr class="memdesc:a348f0d98fcf9602c4bc70126c92f22fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'direction' in a vec3. <br /></td></tr>
<tr class="separator:a348f0d98fcf9602c4bc70126c92f22fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46f8699d461b0cd10b1a0d4debbe3ef"><td class="memItemLeft" align="right" valign="top"><a id="ab46f8699d461b0cd10b1a0d4debbe3ef" name="ab46f8699d461b0cd10b1a0d4debbe3ef"></a>
blockViewDir&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::vec3ToUDirection</b> (const vec3 &amp;direction)</td></tr>
<tr class="memdesc:ab46f8699d461b0cd10b1a0d4debbe3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'direction' in as a Block View Direction by rounding to the nearest direction. <br /></td></tr>
<tr class="separator:ab46f8699d461b0cd10b1a0d4debbe3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7097ce6da8621fa3bc272f5bcd8fb530"><td class="memItemLeft" align="right" valign="top"><a id="a7097ce6da8621fa3bc272f5bcd8fb530" name="a7097ce6da8621fa3bc272f5bcd8fb530"></a>
blockViewDir&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::rotateUDirection</b> (blockViewDir dir, blockViewDir rot)</td></tr>
<tr class="memdesc:a7097ce6da8621fa3bc272f5bcd8fb530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotated direction. <br /></td></tr>
<tr class="separator:a7097ce6da8621fa3bc272f5bcd8fb530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a37c8fea488d892ac54b7e580d22f2"><td class="memItemLeft" align="right" valign="top"><a id="aa6a37c8fea488d892ac54b7e580d22f2" name="aa6a37c8fea488d892ac54b7e580d22f2"></a>
blockViewDir&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::inverseUDirection</b> (blockViewDir dir)</td></tr>
<tr class="memdesc:aa6a37c8fea488d892ac54b7e580d22f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse direction. <br /></td></tr>
<tr class="separator:aa6a37c8fea488d892ac54b7e580d22f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570310427631fce811a9a2ce44d49802"><td class="memItemLeft" align="right" valign="top"><a id="a570310427631fce811a9a2ce44d49802" name="a570310427631fce811a9a2ce44d49802"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>VoxelEng::isalnum</b> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a570310427631fce811a9a2ce44d49802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if 'string' only contains alphanumeric characters or false otherwise. <br /></td></tr>
<tr class="separator:a570310427631fce811a9a2ce44d49802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b331a6e21575026c34ad6b8c661844"><td class="memTemplParams" colspan="2"><a id="a75b331a6e21575026c34ad6b8c661844" name="a75b331a6e21575026c34ad6b8c661844"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75b331a6e21575026c34ad6b8c661844"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VoxelEng::sto</b> (const std::string &amp;str)=delete</td></tr>
<tr class="separator:a75b331a6e21575026c34ad6b8c661844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e97dd744b84cb2d51a43bed545beb7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a12e97dd744b84cb2d51a43bed545beb7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utilities_8h.html#a12e97dd744b84cb2d51a43bed545beb7">VoxelEng::sto</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a12e97dd744b84cb2d51a43bed545beb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string converted into an integer. Throws std::invalid_argument if could not convert.  <a href="utilities_8h.html#a12e97dd744b84cb2d51a43bed545beb7">More...</a><br /></td></tr>
<tr class="separator:a12e97dd744b84cb2d51a43bed545beb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41b71f3ab12c5213c896f9d0e4273b5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab41b71f3ab12c5213c896f9d0e4273b5"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utilities_8h.html#ab41b71f3ab12c5213c896f9d0e4273b5">VoxelEng::sto</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ab41b71f3ab12c5213c896f9d0e4273b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert.  <a href="utilities_8h.html#ab41b71f3ab12c5213c896f9d0e4273b5">More...</a><br /></td></tr>
<tr class="separator:ab41b71f3ab12c5213c896f9d0e4273b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e01401475207ff6266121e723aacc84"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0e01401475207ff6266121e723aacc84"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utilities_8h.html#a0e01401475207ff6266121e723aacc84">VoxelEng::sto</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a0e01401475207ff6266121e723aacc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string converted into a float. Throws std::invalid_argument if could not convert.  <a href="utilities_8h.html#a0e01401475207ff6266121e723aacc84">More...</a><br /></td></tr>
<tr class="separator:a0e01401475207ff6266121e723aacc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7662d56f1641d465df3b5c0c5ed32d39"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7662d56f1641d465df3b5c0c5ed32d39"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utilities_8h.html#a7662d56f1641d465df3b5c0c5ed32d39">VoxelEng::sto</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a7662d56f1641d465df3b5c0c5ed32d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string converted into a char. Throws std::invalid_argument if could not convert.  <a href="utilities_8h.html#a7662d56f1641d465df3b5c0c5ed32d39">More...</a><br /></td></tr>
<tr class="separator:a7662d56f1641d465df3b5c0c5ed32d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce2e8e7fd683ba330449ece591e8014"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acce2e8e7fd683ba330449ece591e8014"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utilities_8h.html#acce2e8e7fd683ba330449ece591e8014">VoxelEng::sto</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:acce2e8e7fd683ba330449ece591e8014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string converted into a bool. Throws std::invalid_argument if could not convert.  <a href="utilities_8h.html#acce2e8e7fd683ba330449ece591e8014">More...</a><br /></td></tr>
<tr class="separator:acce2e8e7fd683ba330449ece591e8014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae245d765dc929ece0dd8bf67da46aa7c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae245d765dc929ece0dd8bf67da46aa7c"><td class="memTemplItemLeft" align="right" valign="top">block&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utilities_8h.html#ae245d765dc929ece0dd8bf67da46aa7c">VoxelEng::sto</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ae245d765dc929ece0dd8bf67da46aa7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.  <a href="utilities_8h.html#ae245d765dc929ece0dd8bf67da46aa7c">More...</a><br /></td></tr>
<tr class="separator:ae245d765dc929ece0dd8bf67da46aa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446a7e705c726475870afd23d706059b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a446a7e705c726475870afd23d706059b"><td class="memTemplItemLeft" align="right" valign="top">blockViewDir&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utilities_8h.html#a446a7e705c726475870afd23d706059b">VoxelEng::sto</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a446a7e705c726475870afd23d706059b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string converted into a Block View Direction. WARNING. It does not convert, for example, a string "PLUSX" into its Block View Direction counterpart. It is used to get the numbers that represent said directions inside the enum and convert them to the proper type. The objective of this is to parse the directions into simple number of 1 digit in the recording files and parse those numbers into their appropriate enum values. Throws std::invalid_argument if could not convert.  <a href="utilities_8h.html#a446a7e705c726475870afd23d706059b">More...</a><br /></td></tr>
<tr class="separator:a446a7e705c726475870afd23d706059b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39f547935db9c5f143eea25d7727d74"><td class="memTemplParams" colspan="2"><a id="ab39f547935db9c5f143eea25d7727d74" name="ab39f547935db9c5f143eea25d7727d74"></a>
template&lt;typename T &gt; <br />
requires std::is_arithmetic&lt;T&gt;</td></tr>
<tr class="memitem:ab39f547935db9c5f143eea25d7727d74"><td class="memTemplItemLeft" align="right" valign="top">::value T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VoxelEng::translateRange</b> (T value, T r1Min, T r1Max, T r2Min, T r2Max)</td></tr>
<tr class="memdesc:ab39f547935db9c5f143eea25d7727d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'value' translated from the range defined in [r1Min, r1Max] to the one defined in [r2Min, r2Max]. <br /></td></tr>
<tr class="separator:ab39f547935db9c5f143eea25d7727d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021135b9aa3f03b6dd6b637f43af6c17"><td class="memTemplParams" colspan="2"><a id="a021135b9aa3f03b6dd6b637f43af6c17" name="a021135b9aa3f03b6dd6b637f43af6c17"></a>
template&lt;typename T &gt; <br />
requires std::is_arithmetic&lt;T&gt;</td></tr>
<tr class="memitem:a021135b9aa3f03b6dd6b637f43af6c17"><td class="memTemplItemLeft" align="right" valign="top">::value std::is_same&lt; T, std::string &gt;::value bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VoxelEng::validatedCinInput</b> (T &amp;var)</td></tr>
<tr class="memdesc:a021135b9aa3f03b6dd6b637f43af6c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts user input into the desirable value. Requires T to satisfy std::is_arithmetic&lt;T&gt;::value || std::is_same&lt;T, std::string&gt;::value. <br /></td></tr>
<tr class="separator:a021135b9aa3f03b6dd6b637f43af6c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9bac29669406cb6e9dfda031d1c45c"><td class="memItemLeft" align="right" valign="top"><a id="a3d9bac29669406cb6e9dfda031d1c45c" name="a3d9bac29669406cb6e9dfda031d1c45c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3d9bac29669406cb6e9dfda031d1c45c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VoxelEng::validatedCinInput</b> (std::string &amp;var)</td></tr>
<tr class="memdesc:a3d9bac29669406cb6e9dfda031d1c45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts user input into the desirable value. <br /></td></tr>
<tr class="separator:a3d9bac29669406cb6e9dfda031d1c45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003ff90c93032f5fe061234904aa238e"><td class="memItemLeft" align="right" valign="top"><a id="a003ff90c93032f5fe061234904aa238e" name="a003ff90c93032f5fe061234904aa238e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a003ff90c93032f5fe061234904aa238e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VoxelEng::validatedCinInput</b> (char &amp;var)</td></tr>
<tr class="memdesc:a003ff90c93032f5fe061234904aa238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts user input into the desirable value. <br /></td></tr>
<tr class="separator:a003ff90c93032f5fe061234904aa238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Contains the declaration of some general utility code that is not directly related to the engine and could potentially be used in other projects easily. </p>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/04/2023 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Abdon Crespo Alvarez @title Utilities. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a12e97dd744b84cb2d51a43bed545beb7" name="a12e97dd744b84cb2d51a43bed545beb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e97dd744b84cb2d51a43bed545beb7">&#9670;&#160;</a></span>sto() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxelEng::sto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string converted into an integer. Throws std::invalid_argument if could not convert. </p>
<p >Returns the string converted into a Block View Direction. WARNING. It does not convert, for example, a string "PLUSX" into its Block View Direction counterpart. It is used to get the numbers that represent said directions inside the enum and convert them to the proper type. The objective of this is to parse the directions into simple number of 1 digit in the recording files and parse those numbers into their appropriate enum values. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>

</div>
</div>
<a id="ab41b71f3ab12c5213c896f9d0e4273b5" name="ab41b71f3ab12c5213c896f9d0e4273b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41b71f3ab12c5213c896f9d0e4273b5">&#9670;&#160;</a></span>sto() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int VoxelEng::sto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>
<p >Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>

</div>
</div>
<a id="a0e01401475207ff6266121e723aacc84" name="a0e01401475207ff6266121e723aacc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e01401475207ff6266121e723aacc84">&#9670;&#160;</a></span>sto() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxelEng::sto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string converted into a float. Throws std::invalid_argument if could not convert. </p>
<p >Returns the string converted into a Block View Direction. WARNING. It does not convert, for example, a string "PLUSX" into its Block View Direction counterpart. It is used to get the numbers that represent said directions inside the enum and convert them to the proper type. The objective of this is to parse the directions into simple number of 1 digit in the recording files and parse those numbers into their appropriate enum values. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>

</div>
</div>
<a id="a7662d56f1641d465df3b5c0c5ed32d39" name="a7662d56f1641d465df3b5c0c5ed32d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7662d56f1641d465df3b5c0c5ed32d39">&#9670;&#160;</a></span>sto() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char VoxelEng::sto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string converted into a char. Throws std::invalid_argument if could not convert. </p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>

</div>
</div>
<a id="acce2e8e7fd683ba330449ece591e8014" name="acce2e8e7fd683ba330449ece591e8014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce2e8e7fd683ba330449ece591e8014">&#9670;&#160;</a></span>sto() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VoxelEng::sto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string converted into a bool. Throws std::invalid_argument if could not convert. </p>
<p >Returns the string converted into a Block View Direction. WARNING. It does not convert, for example, a string "PLUSX" into its Block View Direction counterpart. It is used to get the numbers that represent said directions inside the enum and convert them to the proper type. The objective of this is to parse the directions into simple number of 1 digit in the recording files and parse those numbers into their appropriate enum values. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>

</div>
</div>
<a id="ae245d765dc929ece0dd8bf67da46aa7c" name="ae245d765dc929ece0dd8bf67da46aa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae245d765dc929ece0dd8bf67da46aa7c">&#9670;&#160;</a></span>sto() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">block VoxelEng::sto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string converted into a block ID. Throws std::invalid_argument if could not convert. </p>
<p >Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>

</div>
</div>
<a id="a446a7e705c726475870afd23d706059b" name="a446a7e705c726475870afd23d706059b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446a7e705c726475870afd23d706059b">&#9670;&#160;</a></span>sto() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">blockViewDir VoxelEng::sto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string converted into a Block View Direction. WARNING. It does not convert, for example, a string "PLUSX" into its Block View Direction counterpart. It is used to get the numbers that represent said directions inside the enum and convert them to the proper type. The objective of this is to parse the directions into simple number of 1 digit in the recording files and parse those numbers into their appropriate enum values. Throws std::invalid_argument if could not convert. </p>
<p >Returns the string converted into a Block View Direction. WARNING. It does not convert, for example, a string "PLUSX" into its Block View Direction counterpart. It is used to get the numbers that represent said directions inside the enum and convert them to the proper type. The objective of this is to parse the directions into simple number of 1 digit in the recording files and parse those numbers into their appropriate enum values. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a Block View Direction. WARNING. It does not convert, for example, a string "PLUSX" into its Block View Direction counterpart. It is used to get the numbers that represent said directions inside the enum and convert them to the proper type. The objective of this is to parse the directions into simple number of 1 digit in the recording files and parse those numbers into their appropriate enum values. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a block ID. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into a char. Throws std::invalid_argument if could not convert.</p>
<p >Returns the string converted into an unsigned integer. Throws std::invalid_argument if could not convert. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
