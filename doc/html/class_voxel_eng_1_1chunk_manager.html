<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Deep dive open engine: VoxelEng::chunkManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Deep dive open engine<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">3D graphical voxel engine with AI games API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>VoxelEng</b></li><li class="navelem"><a class="el" href="class_voxel_eng_1_1chunk_manager.html">chunkManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_voxel_eng_1_1chunk_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">VoxelEng::chunkManager Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Used for managing the chunks' life cycle, level loading...  
 <a href="class_voxel_eng_1_1chunk_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="chunk_8h_source.html">chunk.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af08c574bd30f2fbe9a3058c7acdf7855"><td class="memItemLeft" align="right" valign="top"><a id="af08c574bd30f2fbe9a3058c7acdf7855" name="af08c574bd30f2fbe9a3058c7acdf7855"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (unsigned int nChunksToCompute=<a class="el" href="definitions_8h.html#afe7a66d1b2b8f3ba46acc2bd275c8796">DEF_N_CHUNKS_TO_COMPUTE</a>)</td></tr>
<tr class="memdesc:af08c574bd30f2fbe9a3058c7acdf7855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the chunk management system. <br /></td></tr>
<tr class="separator:af08c574bd30f2fbe9a3058c7acdf7855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f264ae01f826c35e3bd32edc5a7137b"><td class="memItemLeft" align="right" valign="top"><a id="a7f264ae01f826c35e3bd32edc5a7137b" name="a7f264ae01f826c35e3bd32edc5a7137b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>initialised</b> ()</td></tr>
<tr class="memdesc:a7f264ae01f826c35e3bd32edc5a7137b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the system is initialised or false otherwise. <br /></td></tr>
<tr class="separator:a7f264ae01f826c35e3bd32edc5a7137b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7005925eede113047d475d675333600f"><td class="memItemLeft" align="right" valign="top"><a id="a7005925eede113047d475d675333600f" name="a7005925eede113047d475d675333600f"></a>
static vec3&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkRelCoords</b> (const vec3 &amp;blockPos)</td></tr>
<tr class="memdesc:a7005925eede113047d475d675333600f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns chunk local coordinates of a global position. <br /></td></tr>
<tr class="separator:a7005925eede113047d475d675333600f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb670633a47195cd5237134a598f0ca"><td class="memItemLeft" align="right" valign="top"><a id="afdb670633a47195cd5237134a598f0ca" name="afdb670633a47195cd5237134a598f0ca"></a>
static vec3&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkRelCoords</b> (float globalX, float globalY, float globalZ)</td></tr>
<tr class="memdesc:afdb670633a47195cd5237134a598f0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns chunk local coordinates of a global position. <br /></td></tr>
<tr class="separator:afdb670633a47195cd5237134a598f0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b0e23a8370d80966ebadcb64b39d93"><td class="memItemLeft" align="right" valign="top"><a id="af6b0e23a8370d80966ebadcb64b39d93" name="af6b0e23a8370d80966ebadcb64b39d93"></a>
static vec3&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkCoords</b> (const vec3 &amp;blockPos)</td></tr>
<tr class="memdesc:af6b0e23a8370d80966ebadcb64b39d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns chunk grid coordinates of a global position. <br /></td></tr>
<tr class="separator:af6b0e23a8370d80966ebadcb64b39d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdad4cfec5e0071f48ca2ff19935efba"><td class="memItemLeft" align="right" valign="top"><a id="afdad4cfec5e0071f48ca2ff19935efba" name="afdad4cfec5e0071f48ca2ff19935efba"></a>
static vec3&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkCoords</b> (float globalX, float globalY, float globalZ)</td></tr>
<tr class="memdesc:afdad4cfec5e0071f48ca2ff19935efba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns chunk local coordinates of a global position. <br /></td></tr>
<tr class="separator:afdad4cfec5e0071f48ca2ff19935efba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb5f28a61b7f1c16c3d4beccc6d9122"><td class="memItemLeft" align="right" valign="top"><a id="aceb5f28a61b7f1c16c3d4beccc6d9122" name="aceb5f28a61b7f1c16c3d4beccc6d9122"></a>
static vec2&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkXZCoords</b> (const vec2 &amp;blockXZPos)</td></tr>
<tr class="memdesc:aceb5f28a61b7f1c16c3d4beccc6d9122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns chunk coordinates in the X and Z axes of a global position in the X and Z axes. <br /></td></tr>
<tr class="separator:aceb5f28a61b7f1c16c3d4beccc6d9122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ed05c8daccf3d0c12fecb54606cd3"><td class="memItemLeft" align="right" valign="top"><a id="add5ed05c8daccf3d0c12fecb54606cd3" name="add5ed05c8daccf3d0c12fecb54606cd3"></a>
static vec2&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkXZCoords</b> (int blockX, int blockZ)</td></tr>
<tr class="memdesc:add5ed05c8daccf3d0c12fecb54606cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns chunk coordinates in the X and Z axes of a global position in the X and Z axes. <br /></td></tr>
<tr class="separator:add5ed05c8daccf3d0c12fecb54606cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bec92ab94599cd134249a375ee6442"><td class="memItemLeft" align="right" valign="top"><a id="a69bec92ab94599cd134249a375ee6442" name="a69bec92ab94599cd134249a375ee6442"></a>
static vec3&#160;</td><td class="memItemRight" valign="bottom"><b>getGlobalPos</b> (const vec3 &amp;chunkPos, const vec3 &amp;inChunkPos)</td></tr>
<tr class="memdesc:a69bec92ab94599cd134249a375ee6442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns global coordinates of a local chunk coordinate from a certain chunk position. <br /></td></tr>
<tr class="separator:a69bec92ab94599cd134249a375ee6442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82642757f468ef25b66c0c73bb9fef4c"><td class="memItemLeft" align="right" valign="top"><a id="a82642757f468ef25b66c0c73bb9fef4c" name="a82642757f468ef25b66c0c73bb9fef4c"></a>
static vec3&#160;</td><td class="memItemRight" valign="bottom"><b>getGlobalPos</b> (int chunkX, int chunkY, int chunkZ, int inChunkX, int inChunkY, int inChunkZ)</td></tr>
<tr class="memdesc:a82642757f468ef25b66c0c73bb9fef4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns global coordinates of a local chunk coordinate from a certain chunk position. <br /></td></tr>
<tr class="separator:a82642757f468ef25b66c0c73bb9fef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad961611f26197e052391f45fd0c3017a"><td class="memItemLeft" align="right" valign="top"><a id="ad961611f26197e052391f45fd0c3017a" name="ad961611f26197e052391f45fd0c3017a"></a>
static vec2&#160;</td><td class="memItemRight" valign="bottom"><b>getXZGlobalPos</b> (const vec2 &amp;chunkPos, const vec2 &amp;inChunkPos)</td></tr>
<tr class="memdesc:ad961611f26197e052391f45fd0c3017a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns global coordinates in the X and Z axes of a local chunk coordinate from a certain chunk position, both in the X and Z axes. <br /></td></tr>
<tr class="separator:ad961611f26197e052391f45fd0c3017a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b9ddd87b560e6fe0b1039e1dadd8df"><td class="memItemLeft" align="right" valign="top"><a id="a42b9ddd87b560e6fe0b1039e1dadd8df" name="a42b9ddd87b560e6fe0b1039e1dadd8df"></a>
static vec2&#160;</td><td class="memItemRight" valign="bottom"><b>getXZGlobalPos</b> (int chunkX, int chunkZ, int inChunkX, int inChunkZ)</td></tr>
<tr class="memdesc:a42b9ddd87b560e6fe0b1039e1dadd8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns global coordinates in the X and Z axes of a local chunk coordinate from a certain chunk position, both in the X and Z axes. <br /></td></tr>
<tr class="separator:a42b9ddd87b560e6fe0b1039e1dadd8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad5d9251599567cff64c1b92665d273"><td class="memItemLeft" align="right" valign="top"><a id="a6ad5d9251599567cff64c1b92665d273" name="a6ad5d9251599567cff64c1b92665d273"></a>
static const std::unordered_map&lt; vec3, <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>chunks</b> ()</td></tr>
<tr class="memdesc:a6ad5d9251599567cff64c1b92665d273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the system's dictionary of registered chunks. <br /></td></tr>
<tr class="separator:a6ad5d9251599567cff64c1b92665d273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ede70b62c9ceb9f4752650678280c3d"><td class="memItemLeft" align="right" valign="top"><a id="a1ede70b62c9ceb9f4752650678280c3d" name="a1ede70b62c9ceb9f4752650678280c3d"></a>
static std::unordered_map&lt; vec3, std::vector&lt; <a class="el" href="struct_voxel_eng_1_1vertex.html">vertex</a> &gt; &gt; const *&#160;</td><td class="memItemRight" valign="bottom"><b>drawableChunksRead</b> ()</td></tr>
<tr class="memdesc:a1ede70b62c9ceb9f4752650678280c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the system's readable chunk vertex data. That is, it returns the system's chunk vertex data that is safe to read for the rendering thread in order to render them. <br /></td></tr>
<tr class="separator:a1ede70b62c9ceb9f4752650678280c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f6ca1e0dd400e131c811354f3d5529"><td class="memItemLeft" align="right" valign="top"><a id="ad8f6ca1e0dd400e131c811354f3d5529" name="ad8f6ca1e0dd400e131c811354f3d5529"></a>
static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>nChunksToCompute</b> ()</td></tr>
<tr class="separator:ad8f6ca1e0dd400e131c811354f3d5529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae072a840144f18966e779dbfc880a126"><td class="memItemLeft" align="right" valign="top"><a id="ae072a840144f18966e779dbfc880a126" name="ae072a840144f18966e779dbfc880a126"></a>
static block&#160;</td><td class="memItemRight" valign="bottom"><b>getBlock</b> (int posX, int posY, int posZ)</td></tr>
<tr class="memdesc:ae072a840144f18966e779dbfc880a126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block ID of a specified global position. <br /></td></tr>
<tr class="separator:ae072a840144f18966e779dbfc880a126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba90bb372b161c80b7bd9626087219"><td class="memItemLeft" align="right" valign="top"><a id="a7cba90bb372b161c80b7bd9626087219" name="a7cba90bb372b161c80b7bd9626087219"></a>
static block&#160;</td><td class="memItemRight" valign="bottom"><b>getBlock</b> (const vec3 &amp;pos)</td></tr>
<tr class="memdesc:a7cba90bb372b161c80b7bd9626087219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block ID of a specified global position. <br /></td></tr>
<tr class="separator:a7cba90bb372b161c80b7bd9626087219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af990d211978fa0e1fcf934b7bde38aa3"><td class="memItemLeft" align="right" valign="top"><a id="af990d211978fa0e1fcf934b7bde38aa3" name="af990d211978fa0e1fcf934b7bde38aa3"></a>
static std::vector&lt; block &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBlocksBox</b> (const vec3 &amp;pos1, const vec3 &amp;pos2)</td></tr>
<tr class="memdesc:af990d211978fa0e1fcf934b7bde38aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all blocks in the world that are in the box defined with the positions pos1 and pos2. <br /></td></tr>
<tr class="separator:af990d211978fa0e1fcf934b7bde38aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fd5263fff316c18ad2899f0649b5c5"><td class="memItemLeft" align="right" valign="top"><a id="a64fd5263fff316c18ad2899f0649b5c5" name="a64fd5263fff316c18ad2899f0649b5c5"></a>
static std::vector&lt; block &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBlocksBox</b> (int x1, int y1, int z1, int x2, int y2, int z2)</td></tr>
<tr class="memdesc:a64fd5263fff316c18ad2899f0649b5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all blocks in the world that are in the box defined with the positions pos1 and pos2. <br /></td></tr>
<tr class="separator:a64fd5263fff316c18ad2899f0649b5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59b369990113a95dc2fc3495eb233f"><td class="memItemLeft" align="right" valign="top"><a id="a0e59b369990113a95dc2fc3495eb233f" name="a0e59b369990113a95dc2fc3495eb233f"></a>
static const std::unordered_set&lt; vec3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>cFreeableChunks</b> ()</td></tr>
<tr class="memdesc:a0e59b369990113a95dc2fc3495eb233f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the chunk position of the system's freeable chunks. <br /></td></tr>
<tr class="separator:a0e59b369990113a95dc2fc3495eb233f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf21a3b78ba3970cefcaf19f4dfcecbd"><td class="memItemLeft" align="right" valign="top"><a id="aaf21a3b78ba3970cefcaf19f4dfcecbd" name="aaf21a3b78ba3970cefcaf19f4dfcecbd"></a>
static const std::atomic&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>cForceSyncFlag</b> ()</td></tr>
<tr class="memdesc:aaf21a3b78ba3970cefcaf19f4dfcecbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the flag that is used to force synchronisation between the chunk management and the rendering thread. <br /></td></tr>
<tr class="separator:aaf21a3b78ba3970cefcaf19f4dfcecbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fb73063c26710221bed9ba0a687c86"><td class="memItemLeft" align="right" valign="top"><a id="a71fb73063c26710221bed9ba0a687c86" name="a71fb73063c26710221bed9ba0a687c86"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInWorld</b> (const vec3 &amp;pos)</td></tr>
<tr class="memdesc:a71fb73063c26710221bed9ba0a687c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given block position is currently inside the loaded area around the player or false otherwise. <br /></td></tr>
<tr class="separator:a71fb73063c26710221bed9ba0a687c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75405c28fcab3a8a37a0ed889a136d6e"><td class="memItemLeft" align="right" valign="top"><a id="a75405c28fcab3a8a37a0ed889a136d6e" name="a75405c28fcab3a8a37a0ed889a136d6e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInWorld</b> (int x, int y, int z)</td></tr>
<tr class="memdesc:a75405c28fcab3a8a37a0ed889a136d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given block position is currently inside the loaded area around the player or false otherwise. <br /></td></tr>
<tr class="separator:a75405c28fcab3a8a37a0ed889a136d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98644191ccd1aba4156066a2c2177046"><td class="memItemLeft" align="right" valign="top"><a id="a98644191ccd1aba4156066a2c2177046" name="a98644191ccd1aba4156066a2c2177046"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isChunkInWorld</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a98644191ccd1aba4156066a2c2177046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given chunk position is inside the level's boundaries or false otherwise. <br /></td></tr>
<tr class="separator:a98644191ccd1aba4156066a2c2177046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69d6a685fcd305d1f3978e6bc60cb47"><td class="memItemLeft" align="right" valign="top"><a id="ac69d6a685fcd305d1f3978e6bc60cb47" name="ac69d6a685fcd305d1f3978e6bc60cb47"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isChunkInWorld</b> (int chunkX, int chunkY, int chunkZ)</td></tr>
<tr class="memdesc:ac69d6a685fcd305d1f3978e6bc60cb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given chunk position is inside the level's boundaries or false otherwise. <br /></td></tr>
<tr class="separator:ac69d6a685fcd305d1f3978e6bc60cb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e079ae2322953eb507d36a43a8074f"><td class="memItemLeft" align="right" valign="top"><a id="a75e079ae2322953eb507d36a43a8074f" name="a75e079ae2322953eb507d36a43a8074f"></a>
static <a class="el" href="chunk_8h.html#a4a390346ea4255bb4664ccdad7a31457">chunkLoadLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkLoadLevel</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a75e079ae2322953eb507d36a43a8074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the chunk's load level. <br /></td></tr>
<tr class="separator:a75e079ae2322953eb507d36a43a8074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56db80a736a3e03795fd85d04cc66c1"><td class="memItemLeft" align="right" valign="top"><a id="aa56db80a736a3e03795fd85d04cc66c1" name="aa56db80a736a3e03795fd85d04cc66c1"></a>
static <a class="el" href="chunk_8h.html#a4a390346ea4255bb4664ccdad7a31457">chunkLoadLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getChunkLoadLevel</b> (int chunkX, int chunkY, int chunkZ)</td></tr>
<tr class="memdesc:aa56db80a736a3e03795fd85d04cc66c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the chunk's load level. <br /></td></tr>
<tr class="separator:aa56db80a736a3e03795fd85d04cc66c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb043896c963a970576500da79e5c5f"><td class="memItemLeft" align="right" valign="top"><a id="adbb043896c963a970576500da79e5c5f" name="adbb043896c963a970576500da79e5c5f"></a>
static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>openedTerrainFileName</b> ()</td></tr>
<tr class="memdesc:adbb043896c963a970576500da79e5c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently opened terrain file. <br /></td></tr>
<tr class="separator:adbb043896c963a970576500da79e5c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d136070567589c30c211beca50b41a"><td class="memItemLeft" align="right" valign="top"><a id="aa3d136070567589c30c211beca50b41a" name="aa3d136070567589c30c211beca50b41a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>infiniteWorld</b> ()</td></tr>
<tr class="memdesc:aa3d136070567589c30c211beca50b41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the system is currently using the infinite world type or false otherwise. <br /></td></tr>
<tr class="separator:aa3d136070567589c30c211beca50b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190df29880cb7d99444cf97d342bc658"><td class="memItemLeft" align="right" valign="top"><a id="a190df29880cb7d99444cf97d342bc658" name="a190df29880cb7d99444cf97d342bc658"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setAImode</b> (bool on)</td></tr>
<tr class="memdesc:a190df29880cb7d99444cf97d342bc658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the system's AI mode on or off. <br /></td></tr>
<tr class="separator:a190df29880cb7d99444cf97d342bc658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2140d7564b0c4685f94ae8f67c916df2"><td class="memItemLeft" align="right" valign="top"><a id="a2140d7564b0c4685f94ae8f67c916df2" name="a2140d7564b0c4685f94ae8f67c916df2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setNChunksToCompute</b> (unsigned int nChunksToCompute)</td></tr>
<tr class="memdesc:a2140d7564b0c4685f94ae8f67c916df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of chunks to compute in the X and Z axes. <br /></td></tr>
<tr class="separator:a2140d7564b0c4685f94ae8f67c916df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4d81212bc88f5fbb2d5f57c75a4c4a"><td class="memItemLeft" align="right" valign="top"><a id="a1f4d81212bc88f5fbb2d5f57c75a4c4a" name="a1f4d81212bc88f5fbb2d5f57c75a4c4a"></a>
static block&#160;</td><td class="memItemRight" valign="bottom"><b>setBlock</b> (const vec3 &amp;pos, block blockID)</td></tr>
<tr class="memdesc:a1f4d81212bc88f5fbb2d5f57c75a4c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the block ID of a specfied block position. <br /></td></tr>
<tr class="separator:a1f4d81212bc88f5fbb2d5f57c75a4c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb99047b06052e916f8d4f512a4a5df"><td class="memItemLeft" align="right" valign="top"><a id="a9eb99047b06052e916f8d4f512a4a5df" name="a9eb99047b06052e916f8d4f512a4a5df"></a>
static block&#160;</td><td class="memItemRight" valign="bottom"><b>setBlock</b> (int x, int y, int z, block blockID)</td></tr>
<tr class="memdesc:a9eb99047b06052e916f8d4f512a4a5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the block ID of a specfied block position. <br /></td></tr>
<tr class="separator:a9eb99047b06052e916f8d4f512a4a5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc15038ff6938e3ff80f62902c730d84"><td class="memItemLeft" align="right" valign="top"><a id="afc15038ff6938e3ff80f62902c730d84" name="afc15038ff6938e3ff80f62902c730d84"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createChunkAt</b> (bool empty, const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:afc15038ff6938e3ff80f62902c730d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the created chunk. <br /></td></tr>
<tr class="separator:afc15038ff6938e3ff80f62902c730d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc08c1ea4c133ba107e105ea2b00253"><td class="memItemLeft" align="right" valign="top"><a id="afdc08c1ea4c133ba107e105ea2b00253" name="afdc08c1ea4c133ba107e105ea2b00253"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createChunkAt</b> (bool empty, int chunkX, int chunkY, int chunkZ)</td></tr>
<tr class="memdesc:afdc08c1ea4c133ba107e105ea2b00253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the created chunk. <br /></td></tr>
<tr class="separator:afdc08c1ea4c133ba107e105ea2b00253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f2cb05cbb047dda35cde8d3fa2afc3"><td class="memItemLeft" align="right" valign="top"><a id="ac4f2cb05cbb047dda35cde8d3fa2afc3" name="ac4f2cb05cbb047dda35cde8d3fa2afc3"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createChunk</b> (bool empty, const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:ac4f2cb05cbb047dda35cde8d3fa2afc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_voxel_eng_1_1chunk_manager.html#afc15038ff6938e3ff80f62902c730d84" title="Returns pointer to the created chunk.">chunkManager::createChunkAt()</a> but with no bounds checking. Returns pointer to the created chunk. <br /></td></tr>
<tr class="separator:ac4f2cb05cbb047dda35cde8d3fa2afc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9945c611810dc230813f4d63fb15976"><td class="memItemLeft" align="right" valign="top"><a id="ac9945c611810dc230813f4d63fb15976" name="ac9945c611810dc230813f4d63fb15976"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createChunk</b> (bool empty, int chunkX, int chunkY, int chunkZ)</td></tr>
<tr class="memdesc:ac9945c611810dc230813f4d63fb15976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_voxel_eng_1_1chunk_manager.html#afc15038ff6938e3ff80f62902c730d84" title="Returns pointer to the created chunk.">chunkManager::createChunkAt()</a> but with no bounds checking. Returns pointer to the created chunk. <br /></td></tr>
<tr class="separator:ac9945c611810dc230813f4d63fb15976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8ec75522ab9281303c79ca8e922242"><td class="memItemLeft" align="right" valign="top"><a id="a8f8ec75522ab9281303c79ca8e922242" name="a8f8ec75522ab9281303c79ca8e922242"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectChunk</b> (int x, int y, int z)</td></tr>
<tr class="memdesc:a8f8ec75522ab9281303c79ca8e922242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a chunk with the specified chunk position. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a8f8ec75522ab9281303c79ca8e922242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49123ea0c8fb060a9bae2a4a722ce091"><td class="memItemLeft" align="right" valign="top"><a id="a49123ea0c8fb060a9bae2a4a722ce091" name="a49123ea0c8fb060a9bae2a4a722ce091"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectChunkByChunkPos</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a49123ea0c8fb060a9bae2a4a722ce091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a chunk with the specified chunk position. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a49123ea0c8fb060a9bae2a4a722ce091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af576f822aea5a1510a159eeaa88dfd2a"><td class="memItemLeft" align="right" valign="top"><a id="af576f822aea5a1510a159eeaa88dfd2a" name="af576f822aea5a1510a159eeaa88dfd2a"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectChunkByChunkPos</b> (int x, int y, int z)</td></tr>
<tr class="memdesc:af576f822aea5a1510a159eeaa88dfd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a chunk with the specified block position. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:af576f822aea5a1510a159eeaa88dfd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301214283671fa2f976404d89f9d6b8a"><td class="memItemLeft" align="right" valign="top"><a id="a301214283671fa2f976404d89f9d6b8a" name="a301214283671fa2f976404d89f9d6b8a"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectChunkByRealPos</b> (const vec3 &amp;pos)</td></tr>
<tr class="memdesc:a301214283671fa2f976404d89f9d6b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a chunk with the specified global position. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a301214283671fa2f976404d89f9d6b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c2a6f5a6e5af91fbb590cf5d21c8ca"><td class="memItemLeft" align="right" valign="top"><a id="a23c2a6f5a6e5af91fbb590cf5d21c8ca" name="a23c2a6f5a6e5af91fbb590cf5d21c8ca"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>neighborMinusX</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a23c2a6f5a6e5af91fbb590cf5d21c8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the neighbor -X chunk for the chunk with the specified chunk position WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a23c2a6f5a6e5af91fbb590cf5d21c8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b9fd0bb90c807f2e31b8db10688832"><td class="memItemLeft" align="right" valign="top"><a id="a73b9fd0bb90c807f2e31b8db10688832" name="a73b9fd0bb90c807f2e31b8db10688832"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>neighborPlusX</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a73b9fd0bb90c807f2e31b8db10688832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the neighbor +X chunk for the chunk with the specified chunk position WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a73b9fd0bb90c807f2e31b8db10688832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f98ad7e4a12139769bc74b1434fac7e"><td class="memItemLeft" align="right" valign="top"><a id="a7f98ad7e4a12139769bc74b1434fac7e" name="a7f98ad7e4a12139769bc74b1434fac7e"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>neighborMinusY</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a7f98ad7e4a12139769bc74b1434fac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the neighbor -Y chunk for the chunk with the specified chunk position WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a7f98ad7e4a12139769bc74b1434fac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3aa02a6f8038ff348d2efdc5701857e"><td class="memItemLeft" align="right" valign="top"><a id="aa3aa02a6f8038ff348d2efdc5701857e" name="aa3aa02a6f8038ff348d2efdc5701857e"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>neighborPlusY</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:aa3aa02a6f8038ff348d2efdc5701857e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the neighbor +Y chunk for the chunk with the specified chunk position WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:aa3aa02a6f8038ff348d2efdc5701857e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa764bda98c3cfeffd491879c84b4e273"><td class="memItemLeft" align="right" valign="top"><a id="aa764bda98c3cfeffd491879c84b4e273" name="aa764bda98c3cfeffd491879c84b4e273"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>neighborMinusZ</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:aa764bda98c3cfeffd491879c84b4e273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the neighbor -Z chunk for the chunk with the specified chunk position WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:aa764bda98c3cfeffd491879c84b4e273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789494f394841dc4f16c343f601a47c"><td class="memItemLeft" align="right" valign="top"><a id="a6789494f394841dc4f16c343f601a47c" name="a6789494f394841dc4f16c343f601a47c"></a>
static <a class="el" href="class_voxel_eng_1_1chunk.html">chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>neighborPlusZ</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a6789494f394841dc4f16c343f601a47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the neighbor +Z chunk for the chunk with the specified chunk position WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a6789494f394841dc4f16c343f601a47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3679f1b3ccaabad1a99fb638a65a114d"><td class="memItemLeft" align="right" valign="top"><a id="a3679f1b3ccaabad1a99fb638a65a114d" name="a3679f1b3ccaabad1a99fb638a65a114d"></a>
static std::unordered_map&lt; vec3, std::vector&lt; <a class="el" href="struct_voxel_eng_1_1vertex.html">vertex</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>drawableChunksWrite</b> ()</td></tr>
<tr class="memdesc:a3679f1b3ccaabad1a99fb638a65a114d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the system's writeable chunk vertex data. That is, it returns the system's chunk vertex data that can be modified by the chunk management thread and chunk meshing threads and that it is not safe for reading. WARNING. This operation is not thread-safe. To push back a chunk's rendering data into this deque, use chunkManager::pushDrawableChunks(...) method to prevent race conditions when using multiple threads in the chunk management system. <br /></td></tr>
<tr class="separator:a3679f1b3ccaabad1a99fb638a65a114d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28c5bfee04124d86e3c004ed1ff5dec"><td class="memItemLeft" align="right" valign="top"><a id="aa28c5bfee04124d86e3c004ed1ff5dec" name="aa28c5bfee04124d86e3c004ed1ff5dec"></a>
static std::recursive_mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>chunksMutex</b> ()</td></tr>
<tr class="memdesc:aa28c5bfee04124d86e3c004ed1ff5dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutex that guards the registered chunks dictionary. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:aa28c5bfee04124d86e3c004ed1ff5dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5901942923d66bf8c3b327d78ca6dd6"><td class="memItemLeft" align="right" valign="top"><a id="ae5901942923d66bf8c3b327d78ca6dd6" name="ae5901942923d66bf8c3b327d78ca6dd6"></a>
static std::recursive_mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>highPriorityListMutex</b> ()</td></tr>
<tr class="memdesc:ae5901942923d66bf8c3b327d78ca6dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutex that guards the chunk high priority update list. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:ae5901942923d66bf8c3b327d78ca6dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbda6caf954384ac87604dce2735073"><td class="memItemLeft" align="right" valign="top"><a id="abdbda6caf954384ac87604dce2735073" name="abdbda6caf954384ac87604dce2735073"></a>
static std::unordered_set&lt; vec3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>freeableChunks</b> ()</td></tr>
<tr class="memdesc:abdbda6caf954384ac87604dce2735073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of freeable chunks. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:abdbda6caf954384ac87604dce2735073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca1aea53d49d99c8a831717ffdffa70"><td class="memItemLeft" align="right" valign="top"><a id="a2ca1aea53d49d99c8a831717ffdffa70" name="a2ca1aea53d49d99c8a831717ffdffa70"></a>
static std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>freeableChunksMutex</b> ()</td></tr>
<tr class="memdesc:a2ca1aea53d49d99c8a831717ffdffa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutex that guards the freeable chunk list. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a2ca1aea53d49d99c8a831717ffdffa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2aab50cda6f0b81311977dcd459a28"><td class="memItemLeft" align="right" valign="top"><a id="abb2aab50cda6f0b81311977dcd459a28" name="abb2aab50cda6f0b81311977dcd459a28"></a>
static std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>managerThreadMutex</b> ()</td></tr>
<tr class="memdesc:abb2aab50cda6f0b81311977dcd459a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutex associated with the chunk management thread. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:abb2aab50cda6f0b81311977dcd459a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf48cf73b511377bc0bbab1c0f665d6a"><td class="memItemLeft" align="right" valign="top"><a id="abf48cf73b511377bc0bbab1c0f665d6a" name="abf48cf73b511377bc0bbab1c0f665d6a"></a>
static std::condition_variable &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>managerThreadCV</b> ()</td></tr>
<tr class="memdesc:abf48cf73b511377bc0bbab1c0f665d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the condition variable associated with the chunk management thread. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:abf48cf73b511377bc0bbab1c0f665d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93649c9bbd26e20e7269c8eb952f99d9"><td class="memItemLeft" align="right" valign="top"><a id="a93649c9bbd26e20e7269c8eb952f99d9" name="a93649c9bbd26e20e7269c8eb952f99d9"></a>
static std::atomic&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forceSyncFlag</b> ()</td></tr>
<tr class="memdesc:a93649c9bbd26e20e7269c8eb952f99d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the flag used to force synchronisation the rendering and chunk management threads. WARNING. Not meant for use in AI mode. <br /></td></tr>
<tr class="separator:a93649c9bbd26e20e7269c8eb952f99d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d265acb6be3e11d5e3d97ddaa7707c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxel_eng_1_1chunk_manager.html#a56d265acb6be3e11d5e3d97ddaa7707c">waitTerrainLoaded</a> ()</td></tr>
<tr class="memdesc:a56d265acb6be3e11d5e3d97ddaa7707c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the calling thread until:  <a href="class_voxel_eng_1_1chunk_manager.html#a56d265acb6be3e11d5e3d97ddaa7707c">More...</a><br /></td></tr>
<tr class="separator:a56d265acb6be3e11d5e3d97ddaa7707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be90fe9601f9418b8bf04eae3b9343c"><td class="memItemLeft" align="right" valign="top"><a id="a4be90fe9601f9418b8bf04eae3b9343c" name="a4be90fe9601f9418b8bf04eae3b9343c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pushDrawableChunks</b> (const <a class="el" href="struct_voxel_eng_1_1chunk_rendering_data.html">chunkRenderingData</a> &amp;renderingData)</td></tr>
<tr class="memdesc:a4be90fe9601f9418b8bf04eae3b9343c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically pushes back a chunk's rendering data into the write drawable chunks deque. <br /></td></tr>
<tr class="separator:a4be90fe9601f9418b8bf04eae3b9343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4db6dff9f4bd67da998280921901aea"><td class="memItemLeft" align="right" valign="top"><a id="ae4db6dff9f4bd67da998280921901aea" name="ae4db6dff9f4bd67da998280921901aea"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>swapDrawableChunksLists</b> ()</td></tr>
<tr class="memdesc:ae4db6dff9f4bd67da998280921901aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the buffers of chunks' vertices. The one used for reading in the renderer thread becomes the one used for writing in the chunk manager thread and vice versa. Sets the meshes updated flag to false and should be called only if it is set to true (check with chunkManager::meshesUpdated(). WARNING. ONLY CALL THIS METHOD WHEN THE RENDERER THREAD AND THE CHUNK MANAGER THREAD ARE SYNCED. <br /></td></tr>
<tr class="separator:ae4db6dff9f4bd67da998280921901aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab6404c348c813b542eb1f5ae1788ca"><td class="memItemLeft" align="right" valign="top"><a id="adab6404c348c813b542eb1f5ae1788ca" name="adab6404c348c813b542eb1f5ae1788ca"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>updatePriorityChunks</b> ()</td></tr>
<tr class="memdesc:adab6404c348c813b542eb1f5ae1788ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update vertex data of all chunks that have a pending hign priority update. WARNING. ONLY CALL THIS METHOD WHEN THE RENDERER THREAD AND THE CHUNK MANAGER THREAD ARE SYNCED. <br /></td></tr>
<tr class="separator:adab6404c348c813b542eb1f5ae1788ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4d7ba7eb8aba561e009370c9d3bbe9"><td class="memItemLeft" align="right" valign="top"><a id="ada4d7ba7eb8aba561e009370c9d3bbe9" name="ada4d7ba7eb8aba561e009370c9d3bbe9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>loadChunk</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:ada4d7ba7eb8aba561e009370c9d3bbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically loads a new chunk at the specified 'chunkPos' chunk position, overwriting any chunks that were already at that position, if any. WARNING. This method is used in with an infinite world. <br /></td></tr>
<tr class="separator:ada4d7ba7eb8aba561e009370c9d3bbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e1af15ec8f8e31cb2bece4f2654098"><td class="memItemLeft" align="right" valign="top"><a id="a84e1af15ec8f8e31cb2bece4f2654098" name="a84e1af15ec8f8e31cb2bece4f2654098"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>unloadChunk</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:a84e1af15ec8f8e31cb2bece4f2654098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads the chunk at chunk position 'chunkPos', pushing it into a free chunks deque to be reused later for another chunk position of the world. WARNING. Non-atomic operation! Must be called when all meshing threads are synced with the chunk management thread. WARNING. This method is used in with an infinite world. <br /></td></tr>
<tr class="separator:a84e1af15ec8f8e31cb2bece4f2654098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d35b99295204c64a2b7c7ff8e132b3b"><td class="memItemLeft" align="right" valign="top"><a id="a6d35b99295204c64a2b7c7ff8e132b3b" name="a6d35b99295204c64a2b7c7ff8e132b3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>meshChunks</b> (const std::atomic&lt; int &gt; &amp;chunkRange, int rangeStart, int rangeEnd, std::shared_mutex &amp;syncMutex, std::condition_variable_any &amp;meshingThreadsCV, std::atomic&lt; bool &gt; &amp;meshingTsCVFlag, std::barrier&lt;&gt; &amp;syncPoint)</td></tr>
<tr class="memdesc:a6d35b99295204c64a2b7c7ff8e132b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by meshing threads to generate meshes for chunks that are close to the player. <br /></td></tr>
<tr class="separator:a6d35b99295204c64a2b7c7ff8e132b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66281b126d74f9612127a9dd48cae0ee"><td class="memItemLeft" align="right" valign="top"><a id="a66281b126d74f9612127a9dd48cae0ee" name="a66281b126d74f9612127a9dd48cae0ee"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>manageChunks</b> (unsigned int nMeshingThreads)</td></tr>
<tr class="memdesc:a66281b126d74f9612127a9dd48cae0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by the chunk management thread to use with infinite world types. It coordinates all meshing threads and manages the chunk unloading process in order to prevent any race condition between said threads, among other things such as synchronization and data transfering with the rendering thread. WARNING. CURRENTLY NOT TESTED, ONLY PROOF OF CONCEPT. <br /></td></tr>
<tr class="separator:a66281b126d74f9612127a9dd48cae0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f558102aeb3a64726affbdc93f7a5"><td class="memItemLeft" align="right" valign="top"><a id="a731f558102aeb3a64726affbdc93f7a5" name="a731f558102aeb3a64726affbdc93f7a5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>finiteWorldLoading</b> (const std::string &amp;terrainFile=&quot;&quot;)</td></tr>
<tr class="memdesc:a731f558102aeb3a64726affbdc93f7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite world loading function for the chunk management thread. Playing AI match records is only supported by this world loading type. If 'terrainFile' is equal to "", then either a new level will be generated or a level from a slot will be loaded (depending on the selected save slot). <br /></td></tr>
<tr class="separator:a731f558102aeb3a64726affbdc93f7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51dc8e3f96ffb3b466dfebcc8e0541e"><td class="memItemLeft" align="right" valign="top"><a id="ae51dc8e3f96ffb3b466dfebcc8e0541e" name="ae51dc8e3f96ffb3b466dfebcc8e0541e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>generateAIWorld</b> (const std::string &amp;path=&quot;&quot;)</td></tr>
<tr class="memdesc:ae51dc8e3f96ffb3b466dfebcc8e0541e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates only block data without the 3D graphics side. Intended to be used when testing or training AI agents without displaying the matches in the engine's graphical mode to save CPU and GPU processing power. This generated world is the original copy. Copies for each AI agent will be generated in chunks as they are needed by their respective agents. If 'path' is equal to "" then a randomly generated world will be created. Otherwise it will load de .terrain file located at 'path' + ".terrain". <br /></td></tr>
<tr class="separator:ae51dc8e3f96ffb3b466dfebcc8e0541e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a56df726d1236704c90b975446b5647"><td class="memItemLeft" align="right" valign="top"><a id="a9a56df726d1236704c90b975446b5647" name="a9a56df726d1236704c90b975446b5647"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>saveAllChunks</b> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a9a56df726d1236704c90b975446b5647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves all loaded chunks. This is intended to be used along with finite world loading. The .terrain file extension is automatically appended. <br /></td></tr>
<tr class="separator:a9a56df726d1236704c90b975446b5647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0926daf50e5a4dc304ae62c784e0c1"><td class="memItemLeft" align="right" valign="top"><a id="a9d0926daf50e5a4dc304ae62c784e0c1" name="a9d0926daf50e5a4dc304ae62c784e0c1"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>loadAllChunks</b> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a9d0926daf50e5a4dc304ae62c784e0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads all chunks from the specified TERRAIN file. This is intended to be used along with finite world loading. The .terrain file extension is automatically appended. <br /></td></tr>
<tr class="separator:a9d0926daf50e5a4dc304ae62c784e0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e71f30460f5f8e5906e2e6d3456cc0"><td class="memItemLeft" align="right" valign="top"><a id="ac3e71f30460f5f8e5906e2e6d3456cc0" name="ac3e71f30460f5f8e5906e2e6d3456cc0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>highPriorityUpdate</b> (const vec3 &amp;chunkPos)</td></tr>
<tr class="memdesc:ac3e71f30460f5f8e5906e2e6d3456cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a chunk in the high priority update list. Only chunks with high priority for being remeshed (such as chunks modified by the player) should be queued into this list. <br /></td></tr>
<tr class="separator:ac3e71f30460f5f8e5906e2e6d3456cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c81fd377975d8d4b6268a744cd2c607"><td class="memItemLeft" align="right" valign="top"><a id="a2c81fd377975d8d4b6268a744cd2c607" name="a2c81fd377975d8d4b6268a744cd2c607"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>selectAIworld</b> (unsigned int individualID)</td></tr>
<tr class="memdesc:a2c81fd377975d8d4b6268a744cd2c607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block and set block operations in the chunk manager system will now be performed on the AI world/level of AI agent with ID 'individualID'. AI mode must be turned on in the chunk manager system. WARNING. This method is not thread safe. <br /></td></tr>
<tr class="separator:a2c81fd377975d8d4b6268a744cd2c607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c1f10f13aab327b7a7a888be4015ad"><td class="memItemLeft" align="right" valign="top"><a id="a04c1f10f13aab327b7a7a888be4015ad" name="a04c1f10f13aab327b7a7a888be4015ad"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>selectOriginalWorld</b> ()</td></tr>
<tr class="memdesc:a04c1f10f13aab327b7a7a888be4015ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY get block operations in the chunk manager system will now be performed on the original copy of the level that is being used for the AI game. AI mode must be turned on in the chunk manager system. Set block operations will use the latest AI world selected (the one corresponding to the AI agent with ID 0 by default). WARNING. This method is not thread safe. <br /></td></tr>
<tr class="separator:a04c1f10f13aab327b7a7a888be4015ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84d72859051399781be8212a5e75e75"><td class="memItemLeft" align="right" valign="top"><a id="af84d72859051399781be8212a5e75e75" name="af84d72859051399781be8212a5e75e75"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>resetAIChunks</b> ()</td></tr>
<tr class="memdesc:af84d72859051399781be8212a5e75e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all copies of chunks owned by AI agents as they never existed (AIChunksAvailable[Any AI World copy][Any chunkCoord] will return false after this). <br /></td></tr>
<tr class="separator:af84d72859051399781be8212a5e75e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cf21819b9c0b43c71da4cc51744d48"><td class="memItemLeft" align="right" valign="top"><a id="af0cf21819b9c0b43c71da4cc51744d48" name="af0cf21819b9c0b43c71da4cc51744d48"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>openedTerrainFileName</b> (const std::string &amp;newName)</td></tr>
<tr class="memdesc:af0cf21819b9c0b43c71da4cc51744d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 'newName' to "" to clear the opened terrain file name. <br /></td></tr>
<tr class="separator:af0cf21819b9c0b43c71da4cc51744d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba752b163801ff360a94bf1325302bc0"><td class="memItemLeft" align="right" valign="top"><a id="aba752b163801ff360a94bf1325302bc0" name="aba752b163801ff360a94bf1325302bc0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>clean</b> ()</td></tr>
<tr class="memdesc:aba752b163801ff360a94bf1325302bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only cleans any resources like chunks created but it does not de-initialise the chunk management system. <br /></td></tr>
<tr class="separator:aba752b163801ff360a94bf1325302bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaca4db6065dc98343fc50f3a333e248"><td class="memItemLeft" align="right" valign="top"><a id="abaca4db6065dc98343fc50f3a333e248" name="abaca4db6065dc98343fc50f3a333e248"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanUp</b> ()</td></tr>
<tr class="memdesc:abaca4db6065dc98343fc50f3a333e248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees any memory allocated in the process of generating the world, like all the Chunk objects created to load it. <br /></td></tr>
<tr class="separator:abaca4db6065dc98343fc50f3a333e248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Used for managing the chunks' life cycle, level loading... </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a56d265acb6be3e11d5e3d97ddaa7707c" name="a56d265acb6be3e11d5e3d97ddaa7707c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d265acb6be3e11d5e3d97ddaa7707c">&#9670;&#160;</a></span>waitTerrainLoaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxelEng::chunkManager::waitTerrainLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the calling thread until: </p>
<ul>
<li>Minimal terrain has been loaded around the player (infinite world).</li>
<li>The entire level has been loaded (finite world). </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>code/<a class="el" href="chunk_8h_source.html">chunk.h</a></li>
<li>code/chunk.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
