<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Deep dive open engine: AIExample::GeneticNeuralNetwork Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Deep dive open engine<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">3D graphical voxel engine with AI games API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>AIExample</b></li><li class="navelem"><a class="el" href="class_a_i_example_1_1_genetic_neural_network.html">GeneticNeuralNetwork</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_i_example_1_1_genetic_neural_network-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AIExample::GeneticNeuralNetwork Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This neural network implementation is meant to be used alongside with genetic algorithms operators such as fitness function, selection, crossover, mutation and replacement to modify the network's weights. Implementations of some of these operators can be found in Deep dive <a class="el" href="genetic_8h.html" title="Contains the implementation of the genetic algorithms used in the example AI game along with the trai...">open/code/AI/genetic.h</a> and Deep dive open/code/AI/genetic.cpp.  
 <a href="class_a_i_example_1_1_genetic_neural_network.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_n_n_8h_source.html">NN.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6ea48823c3b73a909e83865251d9f28"><td class="memItemLeft" align="right" valign="top"><a id="ae6ea48823c3b73a909e83865251d9f28" name="ae6ea48823c3b73a909e83865251d9f28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initNetwork</b> (const std::vector&lt; unsigned int &gt; &amp;sizeLayer, float rangeMin, float rangeMax)</td></tr>
<tr class="memdesc:ae6ea48823c3b73a909e83865251d9f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the neural network with the topology described in layers (number of neurons per layer) and with the respective weights initialized with random values between rangeMin and rangeMax. <br /></td></tr>
<tr class="separator:ae6ea48823c3b73a909e83865251d9f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbd93370999a776db8e4df1baf06780"><td class="memItemLeft" align="right" valign="top"><a id="afcbd93370999a776db8e4df1baf06780" name="afcbd93370999a776db8e4df1baf06780"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GeneticNeuralNetwork</b> ()</td></tr>
<tr class="memdesc:afcbd93370999a776db8e4df1baf06780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty neural network(zero neurons). <br /></td></tr>
<tr class="separator:afcbd93370999a776db8e4df1baf06780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798924c4d8a0535c52c2c4ddeaefc59c"><td class="memItemLeft" align="right" valign="top"><a id="a798924c4d8a0535c52c2c4ddeaefc59c" name="a798924c4d8a0535c52c2c4ddeaefc59c"></a>
const std::vector&lt; af::array &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>weights</b> () const</td></tr>
<tr class="memdesc:a798924c4d8a0535c52c2c4ddeaefc59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the network's weights. WARNING. Not thread-safe. <br /></td></tr>
<tr class="separator:a798924c4d8a0535c52c2c4ddeaefc59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af931543ff24b54a1151590dad5801b07"><td class="memItemLeft" align="right" valign="top"><a id="af931543ff24b54a1151590dad5801b07" name="af931543ff24b54a1151590dad5801b07"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>nLayers</b> () const</td></tr>
<tr class="memdesc:af931543ff24b54a1151590dad5801b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of neuron layers in the network. WARNING. Not thread-safe. <br /></td></tr>
<tr class="separator:af931543ff24b54a1151590dad5801b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5174e0b3f3e9ef32128166d219bf16ac"><td class="memItemLeft" align="right" valign="top"><a id="a5174e0b3f3e9ef32128166d219bf16ac" name="a5174e0b3f3e9ef32128166d219bf16ac"></a>
af::array&#160;</td><td class="memItemRight" valign="bottom"><b>forwardPropagation</b> (const af::array &amp;input)</td></tr>
<tr class="memdesc:a5174e0b3f3e9ef32128166d219bf16ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values corresponding to the output neurons of the network after propagating the 'input' values through it. <br /></td></tr>
<tr class="separator:a5174e0b3f3e9ef32128166d219bf16ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7125e6ec29c4ac56c52f15b6e41c563"><td class="memItemLeft" align="right" valign="top"><a id="aa7125e6ec29c4ac56c52f15b6e41c563" name="aa7125e6ec29c4ac56c52f15b6e41c563"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>forwardPropagationMax</b> (const af::array &amp;input)</td></tr>
<tr class="memdesc:aa7125e6ec29c4ac56c52f15b6e41c563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index corresponding to the output neuron that has the biggest value of the entire output layer after propagating the 'input' values through it. <br /></td></tr>
<tr class="separator:aa7125e6ec29c4ac56c52f15b6e41c563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520c0899ddc4c34a7f1f427e60c95f84"><td class="memItemLeft" align="right" valign="top"><a id="a520c0899ddc4c34a7f1f427e60c95f84" name="a520c0899ddc4c34a7f1f427e60c95f84"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>forwardPropagationMin</b> (const af::array &amp;input)</td></tr>
<tr class="memdesc:a520c0899ddc4c34a7f1f427e60c95f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index corresponding to the output neuron that has the smallest value of the entire output layer after propagating the 'input' values through it. <br /></td></tr>
<tr class="separator:a520c0899ddc4c34a7f1f427e60c95f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1c60f548e83fe1fd7ca0a5b0cec6a7"><td class="memTemplParams" colspan="2"><a id="a5f1c60f548e83fe1fd7ca0a5b0cec6a7" name="a5f1c60f548e83fe1fd7ca0a5b0cec6a7"></a>
template&lt;typename TInput , typename TOutput &gt; <br />
requires std::is_arithmetic&lt;TInput&gt;</td></tr>
<tr class="memitem:a5f1c60f548e83fe1fd7ca0a5b0cec6a7"><td class="memTemplItemLeft" align="right" valign="top">::value &amp;&amp;std::is_arithmetic&lt; TOutput &gt;::value void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forwardPropagation</b> (const std::vector&lt; TInput &gt; &amp;input, TOutput *output, unsigned int &amp;outputSize)</td></tr>
<tr class="memdesc:a5f1c60f548e83fe1fd7ca0a5b0cec6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'output' the values corresponding to the output neurons of the network after propagating the 'input' values through it. WARNING. Do not forget to free the heap memory used to allocate the results in 'output' when it is no longer needed. <br /></td></tr>
<tr class="separator:a5f1c60f548e83fe1fd7ca0a5b0cec6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c73b72196f2b6206786924878b70d26"><td class="memTemplParams" colspan="2"><a id="a8c73b72196f2b6206786924878b70d26" name="a8c73b72196f2b6206786924878b70d26"></a>
template&lt;typename TInput &gt; <br />
requires std::is_arithmetic&lt;TInput&gt;</td></tr>
<tr class="memitem:a8c73b72196f2b6206786924878b70d26"><td class="memTemplItemLeft" align="right" valign="top">::value unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forwardPropagationMax</b> (const std::vector&lt; TInput &gt; &amp;input)</td></tr>
<tr class="memdesc:a8c73b72196f2b6206786924878b70d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index corresponding to the output neuron that has the biggest value of the entire output layer after propagating the 'input' values through it. <br /></td></tr>
<tr class="separator:a8c73b72196f2b6206786924878b70d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358e031a4311e04afd40b3e06d89cef"><td class="memTemplParams" colspan="2"><a id="a2358e031a4311e04afd40b3e06d89cef" name="a2358e031a4311e04afd40b3e06d89cef"></a>
template&lt;typename TInput &gt; <br />
requires std::is_arithmetic&lt;TInput&gt;</td></tr>
<tr class="memitem:a2358e031a4311e04afd40b3e06d89cef"><td class="memTemplItemLeft" align="right" valign="top">::value unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forwardPropagationMin</b> (const std::vector&lt; TInput &gt; &amp;input)</td></tr>
<tr class="memdesc:a2358e031a4311e04afd40b3e06d89cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index corresponding to the output neuron that has the smallest value of the entire output layer after propagating the 'input' values through it. <br /></td></tr>
<tr class="separator:a2358e031a4311e04afd40b3e06d89cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca9076c122f78003441f6e17f94f4c"><td class="memItemLeft" align="right" valign="top"><a id="a11ca9076c122f78003441f6e17f94f4c" name="a11ca9076c122f78003441f6e17f94f4c"></a>
std::vector&lt; af::array &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>weights</b> ()</td></tr>
<tr class="memdesc:a11ca9076c122f78003441f6e17f94f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the network's weights. Do not forget to call <a class="el" href="class_a_i_example_1_1_genetic_neural_network.html#a048469701ebe5f1e38fae3538ba37254" title="Update the network&#39;s number of layers once all modifications to the network&#39;s layers are finished....">GeneticNeuralNetwork::updateNLayers()</a> on the object you called this method on to update the internal counted number of the network's layers if you want to reflect any changes made to said number of layers. WARNING. Not thread-safe. <br /></td></tr>
<tr class="separator:a11ca9076c122f78003441f6e17f94f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048469701ebe5f1e38fae3538ba37254"><td class="memItemLeft" align="right" valign="top"><a id="a048469701ebe5f1e38fae3538ba37254" name="a048469701ebe5f1e38fae3538ba37254"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateNLayers</b> ()</td></tr>
<tr class="memdesc:a048469701ebe5f1e38fae3538ba37254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the network's number of layers once all modifications to the network's layers are finished. WARNING. Not thread-safe. <br /></td></tr>
<tr class="separator:a048469701ebe5f1e38fae3538ba37254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc9cfa94f185525249a3884df752d0e"><td class="memItemLeft" align="right" valign="top"><a id="a3dc9cfa94f185525249a3884df752d0e" name="a3dc9cfa94f185525249a3884df752d0e"></a>
<a class="el" href="class_a_i_example_1_1_genetic_neural_network.html">GeneticNeuralNetwork</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_i_example_1_1_genetic_neural_network.html">GeneticNeuralNetwork</a> &amp;source)</td></tr>
<tr class="memdesc:a3dc9cfa94f185525249a3884df752d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this neural network's topology and weights with the ones from source. <br /></td></tr>
<tr class="separator:a3dc9cfa94f185525249a3884df752d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1c60f548e83fe1fd7ca0a5b0cec6a7"><td class="memTemplParams" colspan="2"><a id="a5f1c60f548e83fe1fd7ca0a5b0cec6a7" name="a5f1c60f548e83fe1fd7ca0a5b0cec6a7"></a>
template&lt;typename TInput , typename TOutput &gt; <br />
requires std::is_arithmetic&lt;TInput&gt;</td></tr>
<tr class="memitem:a5f1c60f548e83fe1fd7ca0a5b0cec6a7"><td class="memTemplItemLeft" align="right" valign="top">::value &amp;&amp;std::is_arithmetic&lt; TOutput &gt;::value void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forwardPropagation</b> (const std::vector&lt; TInput &gt; &amp;input, TOutput *output, unsigned int &amp;outputSize)</td></tr>
<tr class="separator:a5f1c60f548e83fe1fd7ca0a5b0cec6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c73b72196f2b6206786924878b70d26"><td class="memTemplParams" colspan="2"><a id="a8c73b72196f2b6206786924878b70d26" name="a8c73b72196f2b6206786924878b70d26"></a>
template&lt;typename TInput &gt; <br />
requires std::is_arithmetic&lt;TInput&gt;</td></tr>
<tr class="memitem:a8c73b72196f2b6206786924878b70d26"><td class="memTemplItemLeft" align="right" valign="top">::value unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forwardPropagationMax</b> (const std::vector&lt; TInput &gt; &amp;input)</td></tr>
<tr class="separator:a8c73b72196f2b6206786924878b70d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358e031a4311e04afd40b3e06d89cef"><td class="memTemplParams" colspan="2"><a id="a2358e031a4311e04afd40b3e06d89cef" name="a2358e031a4311e04afd40b3e06d89cef"></a>
template&lt;typename TInput &gt; <br />
requires std::is_arithmetic&lt;TInput&gt;</td></tr>
<tr class="memitem:a2358e031a4311e04afd40b3e06d89cef"><td class="memTemplItemLeft" align="right" valign="top">::value unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forwardPropagationMin</b> (const std::vector&lt; TInput &gt; &amp;input)</td></tr>
<tr class="separator:a2358e031a4311e04afd40b3e06d89cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This neural network implementation is meant to be used alongside with genetic algorithms operators such as fitness function, selection, crossover, mutation and replacement to modify the network's weights. Implementations of some of these operators can be found in Deep dive <a class="el" href="genetic_8h.html" title="Contains the implementation of the genetic algorithms used in the example AI game along with the trai...">open/code/AI/genetic.h</a> and Deep dive open/code/AI/genetic.cpp. </p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>code/AI/<a class="el" href="_n_n_8h_source.html">NN.h</a></li>
<li>code/AI/NN.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
